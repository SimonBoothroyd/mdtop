{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"mdtop <p>A simple package for storing topological information about a system to simulate.</p> <p> </p> <p>The <code>mdtop</code> framework aims to provide a simple, modern, and flexible way to store topological information about a system to simulate. While this may be 'yet another <code>Topology</code> object', it is designed to take the best of  all worlds from the fantastic <code>mdtraj</code>, <code>parmed</code>, and <code>openmm</code> packages, and provide a clean way to store atom data, merge multiple topologies, and also select subsets using the ubiquitous <code>PyMol</code> atom selection language.</p>"},{"location":"#installation","title":"Installation","text":"<p>This package can be installed using <code>conda</code> (or <code>mamba</code>, a faster version of <code>conda</code>):</p> <pre><code>mamba install -c conda-forge mdtop\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#creating-a-topology","title":"Creating a Topology","text":"<p>Topologies can be created from a variety of sources. However, the most robust workflows typically involve:</p> <ul> <li>Creating a topology from OpenMM: Use the <code>Topology.from_openmm()</code> method to import   an existing OpenMM topology containing, for example, a protein structure.</li> <li>Creating a topology from an RDKit molecule: Use the <code>Topology.from_rdkit()</code> method   to create a topology from an RDKit molecule representation.</li> <li>Loading a topology from a file: Use the <code>Topology.from_file()</code> method to import   an existing PDB, SDF, or MOL2 file.</li> </ul> <pre><code>from openmm.app import PDBFile\nfrom rdkit import Chem\n\nfrom mdtop import Topology\n\n# Load a protein topology from OpenMM\nprotein_top_omm = PDBFile(\"protein.pdb\").topology\nprotein_top = Topology.from_openmm(protein_top_omm)\n# OR\nprotein_top = Topology.from_file(\"protein.pdb\")\n\n# Load a ligand using RDKit\nligand_rd = Chem.MolFromMolFile(\"ligand.sdf\")\nligand_top = Topology.from_rdkit(ligand_rd)\n# OR\nligand_top = Topology.from_file(\"ligand.sdf\")\n\n# Merge the protein and ligand topologies\nsystem_top = Topology.merge(protein_top, ligand_top)\n# OR\nsystem_top = protein_top + ligand_top\n</code></pre>"},{"location":"#atom-selection","title":"Atom Selection","text":"<p>Subsets of atoms can be selected using a (for now) subset of the PyMol atom selection language.</p> <p>For example, to select all atoms in chain A:</p> <pre><code>selection = system_top.select(\"chain A\")\n</code></pre> <p>or all atoms within 5 \u00c5 of the ligand:</p> <pre><code>atom_idxs = system_top.select(\"all within 5. of resn LIG\")\n</code></pre> <p>A subset of the topology can then be created using the <code>subset()</code> method:</p> <pre><code>subset = system_top.subset(atom_idxs)\n</code></pre> <p>or by indexing directly:</p> <pre><code>subset = system_top[\"chain A\"]\n# OR\nsubset = system_top[atom_idxs]\n</code></pre>"},{"location":"#exporting-topologies","title":"Exporting Topologies","text":"<p>Topologies can be converted back into OpenMM or RDKit formats for further analysis or simulation.</p> <pre><code># Export to OpenMM topology\nsystem_top_omm = system_top.to_openmm()\n\n# Export to RDKit molecule - this currently only works for topologies that contain\n# full formal charge and bond order information.\nmol_rd = ligand_top.to_rdkit()\n</code></pre> <p>They can also be directly written to a file:</p> <pre><code>system_top.to_file(\"system.pdb\")\n</code></pre>"},{"location":"development/","title":"Development","text":"<p>To create a development environment, you must have <code>mamba</code> installed.</p> <p>A development conda environment can be created and activated with:</p> <pre><code>make env\nconda activate mdtop\n</code></pre> <p>To format the codebase:</p> <pre><code>make format\n</code></pre> <p>To run the unit tests:</p> <pre><code>make test\n</code></pre> <p>To serve the documentation locally:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"reference/","title":"mdtop","text":""},{"location":"reference/#mdtop","title":"mdtop","text":"<p>Store topological information about a system to simulate.</p> <p>Modules:</p> <ul> <li> <code>tests</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Atom</code>           \u2013            <p>Represents atoms and virtual sites stored in a topology.</p> </li> <li> <code>Bond</code>           \u2013            <p>Represents a bond between two atoms.</p> </li> <li> <code>Chain</code>           \u2013            <p>Represents chains stored in a topology.</p> </li> <li> <code>Residue</code>           \u2013            <p>Represents residues stored in a topology.</p> </li> <li> <code>Topology</code>           \u2013            <p>Represents topological information about a system.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>AMINO_ACID_NAMES</code>               (<code>frozenset[str]</code>)           \u2013            <p>Common natural amino acid residue names.</p> </li> <li> <code>ION_RES_NAMES</code>               (<code>frozenset[str]</code>)           \u2013            <p>Residue names for common ions.</p> </li> <li> <code>WATER_RES_NAMES</code>               (<code>frozenset[str]</code>)           \u2013            <p>Common water residue names.</p> </li> </ul>"},{"location":"reference/#mdtop.AMINO_ACID_NAMES","title":"AMINO_ACID_NAMES  <code>module-attribute</code>","text":"<pre><code>AMINO_ACID_NAMES: frozenset[str] = frozenset(\n    [\n        \"ACE\",\n        \"NME\",\n        \"NMA\",\n        \"ALA\",\n        \"CYS\",\n        \"ASP\",\n        \"GLU\",\n        \"PHE\",\n        \"GLY\",\n        \"HIS\",\n        \"ILE\",\n        \"LYS\",\n        \"LEU\",\n        \"MET\",\n        \"ASN\",\n        \"PRO\",\n        \"GLN\",\n        \"ARG\",\n        \"SER\",\n        \"THR\",\n        \"VAL\",\n        \"TRP\",\n        \"TYR\",\n        \"CYD\",\n        \"CYZ\",\n        \"HID\",\n        \"HIE\",\n        \"HIP\",\n    ]\n)\n</code></pre> <p>Common natural amino acid residue names.</p>"},{"location":"reference/#mdtop.ION_RES_NAMES","title":"ION_RES_NAMES  <code>module-attribute</code>","text":"<pre><code>ION_RES_NAMES: frozenset[str] = frozenset(\n    [\n        \"NA+\",\n        \"NA\",\n        \"K+\",\n        \"K\",\n        \"LI+\",\n        \"LI\",\n        \"CL-\",\n        \"CL\",\n        \"BR-\",\n        \"BR\",\n        \"I-\",\n        \"I\",\n        \"F-\",\n        \"F\",\n        \"MG+2\",\n        \"MG\",\n        \"CA+2\",\n        \"CA\",\n        \"ZN+2\",\n        \"ZN\",\n        \"FE+3\",\n        \"FE+2\",\n        \"FE\",\n    ]\n)\n</code></pre> <p>Residue names for common ions.</p>"},{"location":"reference/#mdtop.WATER_RES_NAMES","title":"WATER_RES_NAMES  <code>module-attribute</code>","text":"<pre><code>WATER_RES_NAMES: frozenset[str] = frozenset(\n    [\"HOH\", \"WAT\", \"TIP\", \"TIP2\", \"TIP3\", \"TIP4\"]\n)\n</code></pre> <p>Common water residue names.</p>"},{"location":"reference/#mdtop.Atom","title":"Atom","text":"<pre><code>Atom(\n    name: str,\n    atomic_num: int,\n    formal_charge: int | None,\n    serial: int,\n)\n</code></pre> <p>Represents atoms and virtual sites stored in a topology.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the atom.</p> </li> <li> <code>atomic_num</code>               (<code>int</code>)           \u2013            <p>The atomic number, or 0 if this is a virtual site.</p> </li> <li> <code>formal_charge</code>               (<code>int | None</code>)           \u2013            <p>The formal charge on the atom.</p> </li> <li> <code>serial</code>               (<code>int</code>)           \u2013            <p>The index of this atom in its original source (e.g. the serial defined</p> </li> <li> <code>meta</code>               (<code>dict[str, str | float | int | bool]</code>)           \u2013            <p>Extra metadata associated with the atom.</p> </li> <li> <code>symbol</code>               (<code>str</code>)           \u2013            <p>The chemical symbol of the atom, or 'X' if this is a virtual site.</p> </li> <li> <code>residue</code>               (<code>Optional[Residue]</code>)           \u2013            <p>The residue that the atom belongs to.</p> </li> <li> <code>chain</code>               (<code>Optional[Chain]</code>)           \u2013            <p>The chain that the atom belongs to.</p> </li> <li> <code>index</code>               (<code>int | None</code>)           \u2013            <p>The index of the atom in the parent topology</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def __init__(\n    self, name: str, atomic_num: int, formal_charge: int | None, serial: int\n):\n    self.name: str = name\n    \"\"\"The name of the atom.\"\"\"\n\n    self.atomic_num: int = atomic_num\n    \"\"\"The atomic number, or 0 if this is a virtual site.\"\"\"\n    self.formal_charge: int | None = formal_charge\n    \"\"\"The formal charge on the atom.\"\"\"\n\n    self.serial: int = serial\n    \"\"\"The index of this atom in its original source (e.g. the serial defined\n    in a PDB). This may not be zero-index or contiguous.\"\"\"\n\n    self.meta: dict[str, str | float | int | bool] = {}\n    \"\"\"Extra metadata associated with the atom.\"\"\"\n\n    self._residue: typing.Optional[\"Residue\"] = None\n    self._index: int | None = None\n</code></pre>"},{"location":"reference/#mdtop.Atom.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre> <p>The name of the atom.</p>"},{"location":"reference/#mdtop.Atom.atomic_num","title":"atomic_num  <code>instance-attribute</code>","text":"<pre><code>atomic_num: int = atomic_num\n</code></pre> <p>The atomic number, or 0 if this is a virtual site.</p>"},{"location":"reference/#mdtop.Atom.formal_charge","title":"formal_charge  <code>instance-attribute</code>","text":"<pre><code>formal_charge: int | None = formal_charge\n</code></pre> <p>The formal charge on the atom.</p>"},{"location":"reference/#mdtop.Atom.serial","title":"serial  <code>instance-attribute</code>","text":"<pre><code>serial: int = serial\n</code></pre> <p>The index of this atom in its original source (e.g. the serial defined in a PDB). This may not be zero-index or contiguous.</p>"},{"location":"reference/#mdtop.Atom.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, str | float | int | bool] = {}\n</code></pre> <p>Extra metadata associated with the atom.</p>"},{"location":"reference/#mdtop.Atom.symbol","title":"symbol  <code>property</code>","text":"<pre><code>symbol: str\n</code></pre> <p>The chemical symbol of the atom, or 'X' if this is a virtual site.</p>"},{"location":"reference/#mdtop.Atom.residue","title":"residue  <code>property</code>","text":"<pre><code>residue: Optional[Residue]\n</code></pre> <p>The residue that the atom belongs to.</p>"},{"location":"reference/#mdtop.Atom.chain","title":"chain  <code>property</code>","text":"<pre><code>chain: Optional[Chain]\n</code></pre> <p>The chain that the atom belongs to.</p>"},{"location":"reference/#mdtop.Atom.index","title":"index  <code>property</code>","text":"<pre><code>index: int | None\n</code></pre> <p>The index of the atom in the parent topology</p>"},{"location":"reference/#mdtop.Bond","title":"Bond","text":"<pre><code>Bond(idx_1: int, idx_2: int, order: int | None)\n</code></pre> <p>Represents a bond between two atoms.</p> <p>Attributes:</p> <ul> <li> <code>order</code>           \u2013            <p>The formal bond order</p> </li> <li> <code>meta</code>               (<code>dict[str, str | float | int | bool]</code>)           \u2013            <p>Extra metadata associated with the bond.</p> </li> <li> <code>idx_1</code>               (<code>int</code>)           \u2013            <p>The index of the first atom.</p> </li> <li> <code>idx_2</code>               (<code>int</code>)           \u2013            <p>The index of the second atom.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def __init__(self, idx_1: int, idx_2: int, order: int | None):\n    self._idx_1 = idx_1\n    self._idx_2 = idx_2\n    self.order = order\n    \"\"\"The formal bond order\"\"\"\n\n    self.meta: dict[str, str | float | int | bool] = {}\n    \"\"\"Extra metadata associated with the bond.\"\"\"\n</code></pre>"},{"location":"reference/#mdtop.Bond.order","title":"order  <code>instance-attribute</code>","text":"<pre><code>order = order\n</code></pre> <p>The formal bond order</p>"},{"location":"reference/#mdtop.Bond.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, str | float | int | bool] = {}\n</code></pre> <p>Extra metadata associated with the bond.</p>"},{"location":"reference/#mdtop.Bond.idx_1","title":"idx_1  <code>property</code>","text":"<pre><code>idx_1: int\n</code></pre> <p>The index of the first atom.</p>"},{"location":"reference/#mdtop.Bond.idx_2","title":"idx_2  <code>property</code>","text":"<pre><code>idx_2: int\n</code></pre> <p>The index of the second atom.</p>"},{"location":"reference/#mdtop.Chain","title":"Chain","text":"<pre><code>Chain(id_: str)\n</code></pre> <p>Represents chains stored in a topology.</p> <p>Attributes:</p> <ul> <li> <code>id</code>           \u2013            <p>The ID of the chain.</p> </li> <li> <code>topology</code>               (<code>Optional[Topology]</code>)           \u2013            <p>The topology the chain belongs to (if any).</p> </li> <li> <code>residues</code>               (<code>tuple[Residue, ...]</code>)           \u2013            <p>The residues associated with the chain.</p> </li> <li> <code>n_residues</code>               (<code>int</code>)           \u2013            <p>The number of chains in the chain.</p> </li> <li> <code>atoms</code>               (<code>tuple[Atom, ...]</code>)           \u2013            <p>The atoms associated with the chain.</p> </li> <li> <code>n_atoms</code>               (<code>int</code>)           \u2013            <p>The number of atoms in the chain.</p> </li> <li> <code>index</code>               (<code>int | None</code>)           \u2013            <p>The index of the chain in the parent topology</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def __init__(self, id_: str):\n    self.id = id_\n    \"\"\"The ID of the chain.\"\"\"\n\n    self._topology: typing.Optional[\"Topology\"] | None = None\n    self._residues: list[Residue] = []\n\n    self._index: int | None = None\n</code></pre>"},{"location":"reference/#mdtop.Chain.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id = id_\n</code></pre> <p>The ID of the chain.</p>"},{"location":"reference/#mdtop.Chain.topology","title":"topology  <code>property</code>","text":"<pre><code>topology: Optional[Topology]\n</code></pre> <p>The topology the chain belongs to (if any).</p>"},{"location":"reference/#mdtop.Chain.residues","title":"residues  <code>property</code>","text":"<pre><code>residues: tuple[Residue, ...]\n</code></pre> <p>The residues associated with the chain.</p>"},{"location":"reference/#mdtop.Chain.n_residues","title":"n_residues  <code>property</code>","text":"<pre><code>n_residues: int\n</code></pre> <p>The number of chains in the chain.</p>"},{"location":"reference/#mdtop.Chain.atoms","title":"atoms  <code>property</code>","text":"<pre><code>atoms: tuple[Atom, ...]\n</code></pre> <p>The atoms associated with the chain.</p>"},{"location":"reference/#mdtop.Chain.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms: int\n</code></pre> <p>The number of atoms in the chain.</p>"},{"location":"reference/#mdtop.Chain.index","title":"index  <code>property</code>","text":"<pre><code>index: int | None\n</code></pre> <p>The index of the chain in the parent topology</p>"},{"location":"reference/#mdtop.Residue","title":"Residue","text":"<pre><code>Residue(name: str, seq_num: int)\n</code></pre> <p>Represents residues stored in a topology.</p> <p>Attributes:</p> <ul> <li> <code>name</code>           \u2013            <p>The name of the residue.</p> </li> <li> <code>seq_num</code>           \u2013            <p>The sequence number of the residue.</p> </li> <li> <code>chain</code>               (<code>Optional[Chain]</code>)           \u2013            <p>The chain the residue belongs to (if any).</p> </li> <li> <code>topology</code>               (<code>Optional[Topology]</code>)           \u2013            <p>The topology the residue belongs to (if any).</p> </li> <li> <code>atoms</code>               (<code>tuple[Atom, ...]</code>)           \u2013            <p>The atoms associated with the residue.</p> </li> <li> <code>n_atoms</code>               (<code>int</code>)           \u2013            <p>The number of atoms in the residue.</p> </li> <li> <code>index</code>               (<code>int | None</code>)           \u2013            <p>The index of the residue in the parent topology</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def __init__(self, name: str, seq_num: int):\n    self.name = name\n    \"\"\"The name of the residue.\"\"\"\n    self.seq_num = seq_num\n    \"\"\"The sequence number of the residue.\"\"\"\n\n    self._chain: typing.Optional[\"Chain\"] = None\n    self._atoms: list[Atom] = []\n\n    self._index: int | None = None\n</code></pre>"},{"location":"reference/#mdtop.Residue.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre> <p>The name of the residue.</p>"},{"location":"reference/#mdtop.Residue.seq_num","title":"seq_num  <code>instance-attribute</code>","text":"<pre><code>seq_num = seq_num\n</code></pre> <p>The sequence number of the residue.</p>"},{"location":"reference/#mdtop.Residue.chain","title":"chain  <code>property</code>","text":"<pre><code>chain: Optional[Chain]\n</code></pre> <p>The chain the residue belongs to (if any).</p>"},{"location":"reference/#mdtop.Residue.topology","title":"topology  <code>property</code>","text":"<pre><code>topology: Optional[Topology]\n</code></pre> <p>The topology the residue belongs to (if any).</p>"},{"location":"reference/#mdtop.Residue.atoms","title":"atoms  <code>property</code>","text":"<pre><code>atoms: tuple[Atom, ...]\n</code></pre> <p>The atoms associated with the residue.</p>"},{"location":"reference/#mdtop.Residue.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms: int\n</code></pre> <p>The number of atoms in the residue.</p>"},{"location":"reference/#mdtop.Residue.index","title":"index  <code>property</code>","text":"<pre><code>index: int | None\n</code></pre> <p>The index of the residue in the parent topology</p>"},{"location":"reference/#mdtop.Topology","title":"Topology","text":"<pre><code>Topology()\n</code></pre> <p>Represents topological information about a system.</p> <p>Methods:</p> <ul> <li> <code>add_chain</code>             \u2013              <p>Add a new chain to the topology.</p> </li> <li> <code>add_residue</code>             \u2013              <p>Add a new residue to the topology.</p> </li> <li> <code>add_atom</code>             \u2013              <p>Add a new atom to the topology.</p> </li> <li> <code>add_bond</code>             \u2013              <p>Add a new bond to the topology.</p> </li> <li> <code>from_openmm</code>             \u2013              <p>Create a topology from an OpenMM topology.</p> </li> <li> <code>to_openmm</code>             \u2013              <p>Convert the topology to an OpenMM topology.</p> </li> <li> <code>from_rdkit</code>             \u2013              <p>Create a topology from an RDKit molecule.</p> </li> <li> <code>to_rdkit</code>             \u2013              <p>Convert the Topology to an RDKit Mol object.</p> </li> <li> <code>from_openeye</code>             \u2013              <p>Create a topology from an OpenEye molecule.</p> </li> <li> <code>to_openeye</code>             \u2013              <p>Convert the Topology to an OpenEye molecule object.</p> </li> <li> <code>from_file</code>             \u2013              <p>Load the topology from a file.</p> </li> <li> <code>to_file</code>             \u2013              <p>Write the topology to a file.</p> </li> <li> <code>select</code>             \u2013              <p>Select atoms from the topology using a selection expression.</p> </li> <li> <code>subset</code>             \u2013              <p>Create a subset of the topology.</p> </li> <li> <code>merge</code>             \u2013              <p>Merge multiple topologies.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>meta</code>               (<code>dict[str, str | float | int | bool]</code>)           \u2013            <p>Extra metadata associated with the atom.</p> </li> <li> <code>chains</code>               (<code>tuple[Chain, ...]</code>)           \u2013            <p>The chains associated with the topology.</p> </li> <li> <code>n_chains</code>               (<code>int</code>)           \u2013            <p>The number of chains in the topology.</p> </li> <li> <code>residues</code>               (<code>tuple[Residue, ...]</code>)           \u2013            <p>The residues associated with the topology.</p> </li> <li> <code>n_residues</code>               (<code>int</code>)           \u2013            <p>The number of residues in the topology.</p> </li> <li> <code>atoms</code>               (<code>tuple[Atom, ...]</code>)           \u2013            <p>The atoms associated with the topology.</p> </li> <li> <code>n_atoms</code>               (<code>int</code>)           \u2013            <p>The number of atoms in the topology.</p> </li> <li> <code>bonds</code>               (<code>tuple[Bond, ...]</code>)           \u2013            <p>The bonds associated with the topology.</p> </li> <li> <code>n_bonds</code>               (<code>int</code>)           \u2013            <p>The number of bonds in the topology.</p> </li> <li> <code>xyz</code>               (<code>Quantity | None</code>)           \u2013            <p>The coordinates of the atoms in the topology.</p> </li> <li> <code>box</code>               (<code>Quantity | None</code>)           \u2013            <p>The box vectors of the simulation box.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def __init__(self):\n    self._chains: list[Chain] = []\n    self._bonds: list[Bond] = []\n\n    self._n_atoms: int = 0\n    self._n_residues: int = 0\n\n    self._xyz: openmm.unit.Quantity | None = None\n    self._box: openmm.unit.Quantity | None = None\n\n    self.meta: dict[str, str | float | int | bool] = {}\n    \"\"\"Extra metadata associated with the atom.\"\"\"\n</code></pre>"},{"location":"reference/#mdtop.Topology.meta","title":"meta  <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, str | float | int | bool] = {}\n</code></pre> <p>Extra metadata associated with the atom.</p>"},{"location":"reference/#mdtop.Topology.chains","title":"chains  <code>property</code>","text":"<pre><code>chains: tuple[Chain, ...]\n</code></pre> <p>The chains associated with the topology.</p>"},{"location":"reference/#mdtop.Topology.n_chains","title":"n_chains  <code>property</code>","text":"<pre><code>n_chains: int\n</code></pre> <p>The number of chains in the topology.</p>"},{"location":"reference/#mdtop.Topology.residues","title":"residues  <code>property</code>","text":"<pre><code>residues: tuple[Residue, ...]\n</code></pre> <p>The residues associated with the topology.</p>"},{"location":"reference/#mdtop.Topology.n_residues","title":"n_residues  <code>property</code>","text":"<pre><code>n_residues: int\n</code></pre> <p>The number of residues in the topology.</p>"},{"location":"reference/#mdtop.Topology.atoms","title":"atoms  <code>property</code>","text":"<pre><code>atoms: tuple[Atom, ...]\n</code></pre> <p>The atoms associated with the topology.</p>"},{"location":"reference/#mdtop.Topology.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms: int\n</code></pre> <p>The number of atoms in the topology.</p>"},{"location":"reference/#mdtop.Topology.bonds","title":"bonds  <code>property</code>","text":"<pre><code>bonds: tuple[Bond, ...]\n</code></pre> <p>The bonds associated with the topology.</p>"},{"location":"reference/#mdtop.Topology.n_bonds","title":"n_bonds  <code>property</code>","text":"<pre><code>n_bonds: int\n</code></pre> <p>The number of bonds in the topology.</p>"},{"location":"reference/#mdtop.Topology.xyz","title":"xyz  <code>property</code> <code>writable</code>","text":"<pre><code>xyz: Quantity | None\n</code></pre> <p>The coordinates of the atoms in the topology.</p>"},{"location":"reference/#mdtop.Topology.box","title":"box  <code>property</code> <code>writable</code>","text":"<pre><code>box: Quantity | None\n</code></pre> <p>The box vectors of the simulation box.</p>"},{"location":"reference/#mdtop.Topology.add_chain","title":"add_chain","text":"<pre><code>add_chain(id_: str) -&gt; Chain\n</code></pre> <p>Add a new chain to the topology.</p> <p>Parameters:</p> <ul> <li> <code>id_</code>               (<code>str</code>)           \u2013            <p>The ID of the chain to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Chain</code>           \u2013            <p>The newly created chain.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def add_chain(self, id_: str) -&gt; Chain:\n    \"\"\"Add a new chain to the topology.\n\n    Args:\n        id_: The ID of the chain to add.\n\n    Returns:\n         The newly created chain.\n    \"\"\"\n    chain = Chain(id_=id_)\n    chain._topology = self\n    chain._index = self.n_chains\n\n    self._chains.append(chain)\n\n    self._n_atoms += chain.n_atoms\n    self._n_residues += chain.n_residues\n\n    return chain\n</code></pre>"},{"location":"reference/#mdtop.Topology.add_residue","title":"add_residue","text":"<pre><code>add_residue(\n    name: str, seq_num: int | None, chain: Chain\n) -&gt; Residue\n</code></pre> <p>Add a new residue to the topology.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the residue to add</p> </li> <li> <code>seq_num</code>               (<code>int | None</code>)           \u2013            <p>The sequence number of the residue. If <code>None</code>, the index in the topology will be used.</p> </li> <li> <code>chain</code>               (<code>Chain</code>)           \u2013            <p>The parent chain to add to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Residue</code>           \u2013            <p>The newly created residue.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def add_residue(self, name: str, seq_num: int | None, chain: Chain) -&gt; Residue:\n    \"\"\"Add a new residue to the topology.\n\n    Args:\n        name: The name of the residue to add\n        seq_num: The sequence number of the residue. If ``None``, the index in the\n            topology will be used.\n        chain: The parent chain to add to.\n\n    Returns:\n         The newly created residue.\n    \"\"\"\n\n    if chain.topology != self:\n        raise ValueError(f\"{chain} does not belong to this topology.\")\n\n    seq_num = int(self.n_residues if seq_num is None else seq_num)\n\n    residue = Residue(name=name, seq_num=seq_num)\n    residue._chain = chain\n    residue._index = self.n_residues\n\n    chain._residues.append(residue)\n\n    self._n_atoms += residue.n_atoms\n    self._n_residues += 1\n\n    return residue\n</code></pre>"},{"location":"reference/#mdtop.Topology.add_atom","title":"add_atom","text":"<pre><code>add_atom(\n    name: str,\n    atomic_num: int,\n    formal_charge: int | None,\n    serial: int | None,\n    residue: Residue,\n) -&gt; Atom\n</code></pre> <p>Add a new atom to the topology.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the atom to add</p> </li> <li> <code>atomic_num</code>               (<code>int</code>)           \u2013            <p>The atomic number of the atom to add, or 0 for virtual sites.</p> </li> <li> <code>formal_charge</code>               (<code>int | None</code>)           \u2013            <p>The formal charge on the atom (if defined).</p> </li> <li> <code>serial</code>               (<code>int | None</code>)           \u2013            <p>The index of this atom in its original source (e.g. the serial defined in a PDB), which may not be zero-index or contiguous. If <code>None</code>, the index in the topology will be used.</p> </li> <li> <code>residue</code>               (<code>Residue</code>)           \u2013            <p>The parent residue to add to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atom</code>           \u2013            <p>The newly created atom</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def add_atom(\n    self,\n    name: str,\n    atomic_num: int,\n    formal_charge: int | None,\n    serial: int | None,\n    residue: Residue,\n) -&gt; Atom:\n    \"\"\"Add a new atom to the topology.\n\n    Args:\n        name: The name of the atom to add\n        atomic_num: The atomic number of the atom to add, or 0 for virtual sites.\n        formal_charge: The formal charge on the atom (if defined).\n        serial: The index of this atom in its original source (e.g. the serial\n            defined in a PDB), which may not be zero-index or contiguous. If\n            ``None``, the index in the topology will be used.\n        residue: The parent residue to add to.\n\n    Returns:\n        The newly created atom\n    \"\"\"\n    if residue.topology != self:\n        raise ValueError(f\"{residue} does not belong to this topology.\")\n\n    serial = int(self.n_atoms if serial is None else serial)\n\n    atom = Atom(\n        name=name, atomic_num=atomic_num, formal_charge=formal_charge, serial=serial\n    )\n    atom._residue = residue\n    atom._index = self.n_atoms\n\n    residue._atoms.append(atom)\n\n    self._n_atoms += 1\n\n    return atom\n</code></pre>"},{"location":"reference/#mdtop.Topology.add_bond","title":"add_bond","text":"<pre><code>add_bond(idx_1: int, idx_2: int, order: int | None) -&gt; Bond\n</code></pre> <p>Add a new bond to the topology.</p> <p>Parameters:</p> <ul> <li> <code>idx_1</code>               (<code>int</code>)           \u2013            <p>The index of the first atom.</p> </li> <li> <code>idx_2</code>               (<code>int</code>)           \u2013            <p>The index of the second atom.</p> </li> <li> <code>order</code>               (<code>int | None</code>)           \u2013            <p>The formal bond order (if defined).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Bond</code>           \u2013            <p>The newly created bond.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def add_bond(self, idx_1: int, idx_2: int, order: int | None) -&gt; Bond:\n    \"\"\"Add a new bond to the topology.\n\n    Args:\n        idx_1: The index of the first atom.\n        idx_2: The index of the second atom.\n        order: The formal bond order (if defined).\n\n    Returns:\n        The newly created bond.\n    \"\"\"\n\n    if idx_1 &gt;= self.n_atoms:\n        raise ValueError(\"Index 1 is out of range.\")\n    if idx_2 &gt;= self.n_atoms:\n        raise ValueError(\"Index 2 is out of range.\")\n\n    bond = Bond(idx_1=idx_1, idx_2=idx_2, order=order)\n    self._bonds.append(bond)\n\n    return bond\n</code></pre>"},{"location":"reference/#mdtop.Topology.from_openmm","title":"from_openmm  <code>classmethod</code>","text":"<pre><code>from_openmm(topology_omm: Topology) -&gt; Topology\n</code></pre> <p>Create a topology from an OpenMM topology.</p> <p>Parameters:</p> <ul> <li> <code>topology_omm</code>               (<code>Topology</code>)           \u2013            <p>The OpenMM topology to convert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Topology</code>           \u2013            <p>The converted topology.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>@classmethod\ndef from_openmm(cls, topology_omm: openmm.app.Topology) -&gt; \"Topology\":\n    \"\"\"Create a topology from an OpenMM topology.\n\n    Args:\n        topology_omm: The OpenMM topology to convert.\n\n    Returns:\n        The converted topology.\n    \"\"\"\n    topology = cls()\n\n    for chain_omm in topology_omm.chains():\n        chain = topology.add_chain(chain_omm.id)\n\n        for residue_omm in chain_omm.residues():\n            residue = topology.add_residue(residue_omm.name, residue_omm.id, chain)\n\n            for atom_omm in residue_omm.atoms():\n                is_v_site = atom_omm.element is None\n\n                topology.add_atom(\n                    atom_omm.name,\n                    atom_omm.element.atomic_number if not is_v_site else 0,\n                    None if is_v_site else getattr(atom_omm, \"formalCharge\", None),\n                    atom_omm.id,\n                    residue,\n                )\n\n    for bond_omm in topology_omm.bonds():\n        order = bond_omm.order\n\n        if order is None and bond_omm.type is not None:\n            raise NotImplementedError\n\n        topology.add_bond(bond_omm.atom1.index, bond_omm.atom2.index, order)\n\n    if topology_omm.getPeriodicBoxVectors() is not None:\n        box = topology_omm.getPeriodicBoxVectors().value_in_unit(\n            openmm.unit.angstrom\n        )\n        topology.box = numpy.array(box) * openmm.unit.angstrom\n\n    return topology\n</code></pre>"},{"location":"reference/#mdtop.Topology.to_openmm","title":"to_openmm","text":"<pre><code>to_openmm() -&gt; Topology\n</code></pre> <p>Convert the topology to an OpenMM topology.</p> <p>Returns:</p> <ul> <li> <code>Topology</code>           \u2013            <p>The OpenMM topology.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def to_openmm(self) -&gt; openmm.app.Topology:\n    \"\"\"Convert the topology to an OpenMM topology.\n\n    Returns:\n        The OpenMM topology.\n    \"\"\"\n    topology_omm = openmm.app.Topology()\n\n    atoms_omm = []\n\n    for chain in self.chains:\n        chain_omm = topology_omm.addChain(chain.id)\n\n        for residue in chain.residues:\n            residue_omm = topology_omm.addResidue(\n                residue.name, chain_omm, str(residue.seq_num)\n            )\n\n            for atom in residue.atoms:\n                element = (\n                    None\n                    if atom.atomic_num == 0\n                    else openmm.app.Element.getByAtomicNumber(atom.atomic_num)\n                )\n\n                atom_omm = topology_omm.addAtom(\n                    atom.name, element, residue_omm, str(atom.serial)\n                )\n\n                if hasattr(atom_omm, \"formalCharge\"):\n                    atom_omm.formalCharge = atom.formal_charge\n\n                atoms_omm.append(atom_omm)\n\n    bond_order_to_type = {\n        1: openmm.app.Single,\n        2: openmm.app.Double,\n        3: openmm.app.Triple,\n    }\n\n    for bond in self.bonds:\n        topology_omm.addBond(\n            atoms_omm[bond.idx_1],\n            atoms_omm[bond.idx_2],\n            bond_order_to_type[bond.order] if bond.order is not None else None,\n            bond.order,\n        )\n\n    if self.box is not None:\n        topology_omm.setPeriodicBoxVectors(self.box)\n\n    return topology_omm\n</code></pre>"},{"location":"reference/#mdtop.Topology.from_rdkit","title":"from_rdkit  <code>classmethod</code>","text":"<pre><code>from_rdkit(\n    mol: Mol, residue_name: str = \"LIG\", chain: str = \"\"\n) -&gt; Topology\n</code></pre> <p>Create a topology from an RDKit molecule.</p> <p>Parameters:</p> <ul> <li> <code>mol</code>               (<code>Mol</code>)           \u2013            <p>The RDKit molecule to convert.</p> </li> <li> <code>residue_name</code>               (<code>str</code>, default:                   <code>'LIG'</code> )           \u2013            <p>The residue name to use for the ligand.</p> </li> <li> <code>chain</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The chain ID to use for the ligand.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Topology</code>           \u2013            <p>The converted topology.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>@classmethod\ndef from_rdkit(\n    cls, mol: \"Chem.Mol\", residue_name: str = \"LIG\", chain: str = \"\"\n) -&gt; \"Topology\":\n    \"\"\"Create a topology from an RDKit molecule.\n\n    Args:\n        mol: The RDKit molecule to convert.\n        residue_name: The residue name to use for the ligand.\n        chain: The chain ID to use for the ligand.\n\n    Returns:\n        The converted topology.\n    \"\"\"\n    from rdkit import Chem\n\n    mol = Chem.AddHs(mol)\n    Chem.Kekulize(mol)\n\n    topology = cls()\n    topology.add_chain(chain)\n    residue = topology.add_residue(residue_name, 1, topology.chains[0])\n\n    symbol_counter = collections.defaultdict(int)\n\n    for atom_rd in mol.GetAtoms():\n        if atom_rd.GetPDBResidueInfo() is not None:\n            name = atom_rd.GetPDBResidueInfo().GetName()\n        elif atom_rd.HasProp(\"_Name\"):\n            name = atom_rd.GetProp(\"_Name\")\n        else:\n            symbol = atom_rd.GetSymbol()\n            symbol_counter[symbol] += 1\n\n            name = f\"{symbol}{symbol_counter[symbol]}\".ljust(4, \"x\")\n\n        atom = topology.add_atom(\n            name=name,\n            atomic_num=atom_rd.GetAtomicNum(),\n            formal_charge=atom_rd.GetFormalCharge(),\n            serial=atom_rd.GetIdx() + 1,\n            residue=residue,\n        )\n        atom.meta = {\n            k: v\n            for k, v in atom_rd.GetPropsAsDict().items()\n            if k not in _RDKIT_EXCLUDED_ATOM_PROPS\n        }\n\n    for bond_rd in mol.GetBonds():\n        bond = topology.add_bond(\n            idx_1=bond_rd.GetBeginAtomIdx(),\n            idx_2=bond_rd.GetEndAtomIdx(),\n            order=int(bond_rd.GetBondTypeAsDouble()),\n        )\n        bond.meta = {\n            k: v\n            for k, v in bond_rd.GetPropsAsDict().items()\n            if k not in _RDKIT_EXCLUDED_BOND_PROPS\n        }\n\n    topology.meta = {\n        k: v\n        for k, v in mol.GetPropsAsDict().items()\n        if k not in _RDKIT_EXCLUDED_MOL_PROPS\n    }\n\n    if mol.GetNumConformers() &gt;= 1:\n        xyz = mol.GetConformer().GetPositions()\n        topology.xyz = numpy.array(xyz) * openmm.unit.angstrom\n\n    return topology\n</code></pre>"},{"location":"reference/#mdtop.Topology.to_rdkit","title":"to_rdkit","text":"<pre><code>to_rdkit() -&gt; Mol\n</code></pre> <p>Convert the Topology to an RDKit Mol object.</p> Notes <ul> <li>Currently this requires formal charges to be set on the atoms, and   formal bond orders to be set on the bonds.</li> </ul> <p>Returns:</p> <ul> <li> <code>Mol</code>           \u2013            <p>The RDKit Mol object.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def to_rdkit(self) -&gt; \"Chem.Mol\":\n    \"\"\"Convert the Topology to an RDKit Mol object.\n\n    Notes:\n        * Currently this requires formal charges to be set on the atoms, and\n          formal bond orders to be set on the bonds.\n\n    Returns:\n        The RDKit Mol object.\n    \"\"\"\n    from rdkit import Chem\n\n    mol = Chem.RWMol()\n    atoms_rd = []\n\n    for atom in self.atoms:\n        if atom.formal_charge is None:\n            raise ValueError(\"Formal charges must be set on all atoms.\")\n\n        atom_rd = Chem.Atom(atom.atomic_num)\n        atom_rd.SetFormalCharge(atom.formal_charge)\n        atom_rd.SetProp(\"_Name\", atom.name)\n\n        _set_rd_meta(atom_rd, atom.meta)\n\n        res_info = Chem.AtomPDBResidueInfo(\n            atom.name,\n            atom.serial,\n            \"\",\n            atom.residue.name,\n            atom.residue.seq_num,\n            atom.residue.chain.id,\n            isHeteroAtom=atom.residue.name not in AMINO_ACID_NAMES,\n        )\n        atom_rd.SetPDBResidueInfo(res_info)\n\n        atoms_rd.append(mol.AddAtom(atom_rd))\n\n    bond_order_to_type = {\n        1: Chem.BondType.SINGLE,\n        2: Chem.BondType.DOUBLE,\n        3: Chem.BondType.TRIPLE,\n    }\n    for bond in self.bonds:\n        if bond.order is None:\n            raise ValueError(\"Formal bond orders must be set on all bonds.\")\n        if bond.order not in bond_order_to_type:\n            raise NotImplementedError(f\"Bond order {bond.order} is not supported.\")\n\n        mol.AddBond(bond.idx_1, bond.idx_2, bond_order_to_type[bond.order])\n\n        bond_rd = mol.GetBondBetweenAtoms(bond.idx_1, bond.idx_2)\n        _set_rd_meta(bond_rd, bond.meta)\n\n    if self.xyz is not None:\n        xyz = self.xyz.value_in_unit(openmm.unit.angstrom)\n        conf = Chem.Conformer(len(atoms_rd))\n\n        for idx, pos in enumerate(xyz):\n            conf.SetAtomPosition(idx, pos)\n\n        mol.AddConformer(conf, assignId=True)\n\n    _set_rd_meta(mol, self.meta)\n\n    Chem.SanitizeMol(mol)\n    return Chem.Mol(mol)\n</code></pre>"},{"location":"reference/#mdtop.Topology.from_openeye","title":"from_openeye  <code>classmethod</code>","text":"<pre><code>from_openeye(mol: OEMol) -&gt; Topology\n</code></pre> <p>Create a topology from an OpenEye molecule.</p> <p>Parameters:</p> <ul> <li> <code>mol</code>               (<code>OEMol</code>)           \u2013            <p>The RDKit molecule to convert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Topology</code>           \u2013            <p>The converted topology.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>@classmethod\ndef from_openeye(cls, mol: \"oechem.OEMol\") -&gt; \"Topology\":  # pragma: no cover\n    \"\"\"Create a topology from an OpenEye molecule.\n\n    Args:\n        mol: The RDKit molecule to convert.\n\n    Returns:\n        The converted topology.\n    \"\"\"\n    from openeye import oechem\n\n    if oechem.OEHasImplicitHydrogens(mol):\n        assert oechem.OEAddExplicitHydrogens(mol)\n\n    atoms_by_chain = collections.defaultdict(lambda: collections.defaultdict(list))\n\n    res_num_to_name = {}\n    res_num_to_chain_id = {}\n\n    topology = cls()\n\n    for i, atom_oe in enumerate(mol.GetAtoms()):\n        atomic_num = atom_oe.GetAtomicNum()\n        formal_charge = atom_oe.GetFormalCharge()\n\n        name = atom_oe.GetName()\n\n        res_name = \"\"\n        res_num = 0\n\n        chain_id = \"\"\n\n        serial = None\n\n        if oechem.OEHasResidue(atom_oe):\n            residue_oe: oechem.OEResidue = oechem.OEAtomGetResidue(atom_oe)\n\n            res_name = residue_oe.GetName()\n            res_num = residue_oe.GetResidueNumber()\n\n            serial = residue_oe.GetSerialNumber()\n\n            chain_id = residue_oe.GetChainID()\n\n        res_num_to_name[res_num] = res_name\n        res_num_to_chain_id[res_num] = chain_id\n\n        assert (\n            res_num not in res_num_to_name\n            or res_name == res_num_to_name[res_num]\n            or chain_id not in res_num_to_chain_id\n            or chain_id != res_num_to_chain_id[res_num]\n        )\n\n        meta = {\n            oechem.OEGetTag(pair.GetTag()): pair.GetData()\n            for pair in atom_oe.GetDataIter()\n            if len(oechem.OEGetTag(pair.GetTag())) &gt; 0\n        }\n\n        atoms_by_chain[chain_id][res_num].append(\n            (i, name, atomic_num, formal_charge, serial, meta)\n        )\n\n    atom_idx_old_to_new = {}\n\n    for chain_id, residues in atoms_by_chain.items():\n        chain = topology.add_chain(chain_id)\n\n        for res_num, atoms in residues.items():\n            residue = topology.add_residue(res_num_to_name[res_num], res_num, chain)\n\n            for (\n                idx_old,\n                name,\n                atomic_num,\n                formal_charge,\n                serial,\n                meta,\n            ) in atoms:\n                atom = topology.add_atom(\n                    name, atomic_num, formal_charge, serial, residue\n                )\n                atom.meta = meta\n\n                atom_idx_old_to_new[idx_old] = atom.index\n\n    if any(idx_old != idx_new for idx_old, idx_new in atom_idx_old_to_new.items()):\n        _LOGGER.warning(\"Atoms were re-ordered so residues are contiguous.\")\n\n    for bond_oe in mol.GetBonds():\n        idx_1 = atom_idx_old_to_new[bond_oe.GetBgnIdx()]\n        idx_2 = atom_idx_old_to_new[bond_oe.GetEndIdx()]\n\n        order = bond_oe.GetOrder()\n\n        bond = topology.add_bond(idx_1, idx_2, order)\n        bond.meta = {\n            oechem.OEGetTag(pair.GetTag()): pair.GetData()\n            for pair in bond_oe.GetDataIter()\n            if len(oechem.OEGetTag(pair.GetTag())) &gt; 0\n        }\n\n    topology.meta = {\n        oechem.OEGetTag(pair.GetTag()): pair.GetData()\n        for pair in mol.GetDataIter()\n        if len(oechem.OEGetTag(pair.GetTag())) &gt; 0\n    }\n\n    if mol.NumConfs() == 1:\n        coords_dict = mol.GetCoords()\n        topology.xyz = numpy.array([coords_dict[i] for i in range(mol.NumAtoms())])\n    elif mol.NumConfs() &gt; 1:\n        raise NotImplementedError(\"Multiple conformers are not supported.\")\n\n    return topology\n</code></pre>"},{"location":"reference/#mdtop.Topology.to_openeye","title":"to_openeye","text":"<pre><code>to_openeye() -&gt; OEMol\n</code></pre> <p>Convert the Topology to an OpenEye molecule object.</p> Notes <ul> <li>Currently this requires formal charges to be set on the atoms, and   formal bond orders to be set on the bonds.</li> </ul> <p>Returns:</p> <ul> <li> <code>OEMol</code>           \u2013            <p>The OpenEye molecule.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def to_openeye(self) -&gt; \"oechem.OEMol\":  # pragma: no cover\n    \"\"\"Convert the Topology to an OpenEye molecule object.\n\n    Notes:\n        * Currently this requires formal charges to be set on the atoms, and\n          formal bond orders to be set on the bonds.\n\n    Returns:\n        The OpenEye molecule.\n    \"\"\"\n    from openeye import oechem\n\n    mol = oechem.OEMol()\n    atoms_oe = []\n\n    for atom in self.atoms:\n        if atom.formal_charge is None:\n            raise ValueError(\"Formal charges must be set on all atoms.\")\n\n        atom_oe: oechem.OEAtomBase = mol.NewAtom(atom.atomic_num)\n        atom_oe.SetFormalCharge(atom.formal_charge)\n        atom_oe.SetName(atom.name)\n\n        _set_oe_meta(atom_oe, atom.meta)\n\n        res_info = oechem.OEAtomGetResidue(atom_oe)\n        res_info.SetName(atom.residue.name)\n        res_info.SetResidueNumber(atom.residue.seq_num)\n        res_info.SetChainID(atom.residue.chain.id)\n        res_info.SetSerialNumber(atom.serial)\n\n        oechem.OEAtomSetResidue(atom_oe, res_info)\n\n        atoms_oe.append(atom_oe)\n\n    for bond in self.bonds:\n        if bond.order is None:\n            raise ValueError(\"Formal bond orders must be set on all bonds.\")\n\n        bond_oe = mol.NewBond(\n            atoms_oe[bond.idx_1], atoms_oe[bond.idx_2], bond.order\n        )\n        _set_oe_meta(bond_oe, bond.meta)\n\n    if self.xyz is not None:\n        xyz = self.xyz.value_in_unit(openmm.unit.angstrom)\n\n        coords = oechem.OEFloatArray(3 * self.n_atoms)\n\n        for idx, pos in enumerate(xyz):\n            coords[idx * 3] = pos[0]\n            coords[idx * 3 + 1] = pos[1]\n            coords[idx * 3 + 2] = pos[2]\n\n        mol.DeleteConfs()\n        mol.NewConf(coords)\n\n    _set_oe_meta(mol, self.meta)\n\n    oechem.OEFindRingAtomsAndBonds(mol)\n    return mol\n</code></pre>"},{"location":"reference/#mdtop.Topology._from_pdb","title":"_from_pdb  <code>classmethod</code>","text":"<pre><code>_from_pdb(path: Path) -&gt; Topology\n</code></pre> <p>Load the topology from a PDB file.</p> Source code in <code>mdtop/_top.py</code> <pre><code>@classmethod\ndef _from_pdb(cls, path: pathlib.Path) -&gt; \"Topology\":\n    \"\"\"Load the topology from a PDB file.\"\"\"\n    pdb = openmm.app.PDBFile(str(path))\n\n    topology = cls.from_openmm(pdb.topology)\n\n    xyz = pdb.positions.value_in_unit(openmm.unit.angstrom)\n    topology.xyz = numpy.array(xyz) * openmm.unit.angstrom\n\n    return topology\n</code></pre>"},{"location":"reference/#mdtop.Topology.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(path: Path | str) -&gt; Topology\n</code></pre> <p>Load the topology from a file.</p> Notes <ul> <li>Currently PDB, SDF, and MOL2 files are supported.</li> </ul> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path | str</code>)           \u2013            <p>The path to the file to load.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Topology</code>           \u2013            <p>The loaded topology.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>@classmethod\ndef from_file(cls, path: pathlib.Path | str) -&gt; \"Topology\":\n    \"\"\"Load the topology from a file.\n\n    Notes:\n        * Currently PDB, SDF, and MOL2 files are supported.\n\n    Args:\n        path: The path to the file to load.\n\n    Returns:\n        The loaded topology.\n    \"\"\"\n    path = pathlib.Path(path)\n\n    if path.suffix.lower() == \".pdb\":\n        return cls._from_pdb(path)\n    elif path.suffix.lower() in {\".mol\", \".sdf\"}:\n        from rdkit import Chem\n\n        mol = Chem.MolFromMolFile(str(path), removeHs=False)\n        return cls.from_rdkit(mol)\n    elif path.suffix.lower() == \".mol2\":\n        from rdkit import Chem\n\n        mol = Chem.MolFromMol2File(str(path), removeHs=False)\n        return cls.from_rdkit(mol)\n\n    raise NotImplementedError(f\"{path.suffix} files are not supported.\")\n</code></pre>"},{"location":"reference/#mdtop.Topology.to_file","title":"to_file","text":"<pre><code>to_file(path: Path | str)\n</code></pre> <p>Write the topology to a file.</p> Notes <ul> <li>Currently PDB, MOL, and SDF files are supported.</li> <li>SDF / MOL writing requires that all atoms have formal charges set, and   all bonds have formal bond orders set, as reading and writing is via   RDKit.</li> <li>Not all metadata will be preserved when writing to files, including   residue and chain information.</li> </ul> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path | str</code>)           \u2013            <p>The path to write the topology to.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def to_file(self, path: pathlib.Path | str):\n    \"\"\"Write the topology to a file.\n\n    Notes:\n        * Currently PDB, MOL, and SDF files are supported.\n        * SDF / MOL writing requires that all atoms have formal charges set, and\n          all bonds have formal bond orders set, as reading and writing is via\n          RDKit.\n        * Not all metadata will be preserved when writing to files, including\n          residue and chain information.\n\n    Args:\n        path: The path to write the topology to.\n    \"\"\"\n    path = pathlib.Path(path)\n\n    if path.suffix.lower() == \".pdb\":\n        xyz = self.xyz if self.xyz is not None else numpy.zeros((self.n_atoms, 3))\n        openmm.app.PDBFile.writeFile(self.to_openmm(), xyz, str(path))\n        return\n    elif path.suffix.lower() in {\".mol\", \".sdf\"}:\n        from rdkit import Chem\n\n        with Chem.SDWriter(str(path)) as writer:\n            writer.write(self.to_rdkit())\n        return\n\n    raise NotImplementedError(f\"{path.suffix} files are not supported.\")\n</code></pre>"},{"location":"reference/#mdtop.Topology.select","title":"select","text":"<pre><code>select(expr: str) -&gt; ndarray\n</code></pre> <p>Select atoms from the topology using a selection expression.</p> <p>The selection expression should be expressed in terms of the PyMol selection language. For example, to select all atoms in chain A:</p> <pre><code>selection = topology.select(\"chain A\")\n</code></pre> <p>or all atoms within 5 \u00c5 of the ligand:</p> <pre><code>selection = topology.select(\"all within 5 of resn LIG\")\n</code></pre> Notes <p>An Amber-style selection mask can also be used, but this is deprecated and will be removed in a future version.</p> <p>Parameters:</p> <ul> <li> <code>expr</code>               (<code>str</code>)           \u2013            <p>The selection expression.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def select(self, expr: str) -&gt; numpy.ndarray:\n    \"\"\"Select atoms from the topology using a selection expression.\n\n    The selection expression should be expressed in terms of the PyMol\n    selection language. For example, to select all atoms in chain A:\n\n    ```python\n    selection = topology.select(\"chain A\")\n    ```\n\n    or all atoms within 5 \u00c5 of the ligand:\n\n    ```python\n    selection = topology.select(\"all within 5 of resn LIG\")\n    ```\n\n    Notes:\n        An Amber-style selection mask can also be used, but this is deprecated\n        and will be removed in a future version.\n\n    Args:\n        expr: The selection expression.\n    \"\"\"\n    idxs = self._select_amber(expr)\n\n    if idxs is not None:\n        return idxs\n\n    return select(self, expr)\n</code></pre>"},{"location":"reference/#mdtop.Topology.subset","title":"subset","text":"<pre><code>subset(idxs: Iterable[int]) -&gt; Topology\n</code></pre> <p>Create a subset of the topology.</p> <p>Parameters:</p> <ul> <li> <code>idxs</code>               (<code>Iterable[int]</code>)           \u2013            <p>The indices of the atoms to include in the subset. Note the order of the atoms in the subset will be the same as in the original topology, regardless of the order of the indices.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Topology</code>           \u2013            <p>The subset of the topology.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>def subset(self, idxs: typing.Iterable[int]) -&gt; \"Topology\":\n    \"\"\"Create a subset of the topology.\n\n    Args:\n        idxs: The indices of the atoms to include in the subset. Note the order of\n            the atoms in the subset will be the same as in the original topology,\n            regardless of the order of the indices.\n\n    Returns:\n        The subset of the topology.\n    \"\"\"\n    idxs = numpy.array(idxs)\n    idxs_unique = set(idxs)\n\n    if len(idxs_unique) != len(idxs):\n        raise ValueError(\"Indices are not unique.\")\n\n    subset = Topology()\n\n    idx_old_to_new = {}\n\n    for chain in self.chains:\n        has_chain = any(\n            atom.index in idxs_unique\n            for residue in chain.residues\n            for atom in residue.atoms\n        )\n\n        if not has_chain:\n            continue\n\n        chain_new = subset.add_chain(chain.id)\n\n        for residue in chain.residues:\n            has_residue = any(atom.index in idxs_unique for atom in residue.atoms)\n\n            if not has_residue:\n                continue\n\n            residue_new = subset.add_residue(\n                residue.name, residue.seq_num, chain_new\n            )\n\n            for atom in residue.atoms:\n                if atom.index not in idxs_unique:\n                    continue\n\n                atom_new = subset.add_atom(\n                    atom.name,\n                    atom.atomic_num,\n                    atom.formal_charge,\n                    atom.serial,\n                    residue_new,\n                )\n                idx_old_to_new[atom.index] = atom_new.index\n\n    for bond in self.bonds:\n        if bond.idx_1 not in idxs_unique or bond.idx_2 not in idxs_unique:\n            continue\n\n        subset.add_bond(\n            idx_old_to_new[bond.idx_1], idx_old_to_new[bond.idx_2], bond.order\n        )\n\n    subset.box = self.box\n    subset.xyz = None if self.xyz is None else self.xyz[idxs]\n\n    return subset\n</code></pre>"},{"location":"reference/#mdtop.Topology.merge","title":"merge  <code>classmethod</code>","text":"<pre><code>merge(*topologies: Topology) -&gt; Topology\n</code></pre> <p>Merge multiple topologies.</p> Notes <ul> <li>The box vectors of the first topology will be used.</li> <li>Topologies without coordinates will be treated as if they have all zero   coordinates.</li> </ul> <p>Parameters:</p> <ul> <li> <code>topologies</code>               (<code>Topology</code>, default:                   <code>()</code> )           \u2013            <p>The topologies to merge together.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Topology</code>           \u2013            <p>The merged topology.</p> </li> </ul> Source code in <code>mdtop/_top.py</code> <pre><code>@classmethod\ndef merge(cls, *topologies: \"Topology\") -&gt; \"Topology\":\n    \"\"\"Merge multiple topologies.\n\n    Notes:\n        * The box vectors of the first topology will be used.\n        * Topologies without coordinates will be treated as if they have all zero\n          coordinates.\n\n    Args:\n        topologies: The topologies to merge together.\n\n    Returns:\n        The merged topology.\n    \"\"\"\n\n    if len(topologies) == 0:\n        return cls()\n\n    merged = copy.deepcopy(topologies[0])\n\n    for topology in topologies[1:]:\n        merged += topology\n\n    return merged\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>mdtop</li> </ul>"}]}